<!---
title: '소수'
category: Mathematics
language: Korean
--->

# 소수

**소수**는 $1$과 자신 외의 자연수로 나누어 떨어지지 않는 수이다.
또한, 2개 이상의 소수의 곱으로 나타내어지는 수를 **합성수**라고 한다.
예를 들어, $17$은 소수이다. $54$는 합성수이다.
편의상, 이 노트에서는 양의 소수만을 소수라고 할 것이다. 약수 또한 양의 약수를 의미한다.

**명제**. $\forall n\in\N, n\geq 2$의 $1$을 제외한 약수 중, 최소의 것은 소수이다.

*증명*. 위에서 언급한 $1$을 제외한 최소의 약수를 $p$라고 하자.
$p\mid n$이므로, $\exists m\in\N, n=mp$이다.
그런데 $p$가 소수가 아니라고 하면 $\exists a,b\in\N, (1<a,b<p) \land (p=ab)$이고,
$n = abm$이다. 따라서 $a\mid n$이고, $p$가 최소의 $1$이 아닌 약수라는 조건에 모순이므로
$p$는 소수이다. □

위 명제에 따르면, 어떤 $1$이상의 자연수 $n$이 주어졌을 때,
$n$의 $1$이 아닌 약수 중 최소의 것인 $p_1$이 존재할 것이고,
$\frac{n}{p_1}\in\N$이므로, 다시 $1$이 아닌 약수 중 최소의 것을 $p_2$로
잡아, 이러한 연산을 계속하여 반복하는 것이 가능할 것이다.
이 연산이 성립하지 않을 때까지의 결과를 늘어 놓으면

$$
n > \frac{n}{p_1} > \frac{n}{p_1p_2}> \frac{n}{p_1p_2p_3} \cdots
$$

와 같을 것이고, 위는 단조 감소의 자연수열이므로 결국에는 $\frac{n}{p_1p_2\cdots p_r}=1$인
$r\in\N$이 존재한다는 사실을 알 수 있다.
따라서 모든 $2$이상의 자연수는 소수 혹은 소수의 곱으로 표현하는 것이 가능하며,
더 나아가 소수와 합성수 중 하나에 해당함을 알 수 있다.
이 때, $n=p_1p_2\cdots p_r$과 같이 소수의 곱의 형식으로 표현한것을 **소인수분해**라고 한다.

## 소수는 무한히 존재한다

가장 작은 소수인 $2$부터, 오름차순으로 소수들을
$2, 3, 5, 7, 11,\ldots$와 같이 나열할 수 있다.
그리고 이 수열은 끝나지 않는다. 소수는 무한히 존재하기 때문이다.

**정리**. 소수는 무한히 존재한다.

*증명*(Euclid의 증명). 소수가 총 $N$개 존재하여 유한하다고 가정하고, 최소의 소수부터
최대의 소수가 오름차순이 되도록 나열한 것을 $p_1, p_2, \ldots, p_N$이라고 하자.
$P:=p_1p_2\cdots p_N+1$으로 두면, $P$는 소수가 아니므로 합성수일 것이고,
$p_i\mid P$인 $i\in\{1,2,\ldots,N\}$이 존재할 것이다. 따라서
$p_i | 1 = P - p_1p_2\cdots p_N$여야 하나, 이를 만족하는 소수는 만족하지 않으므로 모순이다.
따라서 소수는 무한히 존재한다. □

*증명*(Euler의 증명).
크기 오름차순으로 소수를 나열했을 때, $n$번째의 소수를 $p_n$으로 두자.
$p_n\geq2$이므로, $s>1$에 대해 $0<p_n^{-s}<1$이다. 따라서

$$
\begin{aligned}
\left(1-p_n^{-s}\right)^{-1} &= \sum_{j=0}^{\infty}p_n^{-js} \\
\prod_{n=1}^{N}\left(1-p_n^{-s}\right)^{-1} &=
\left(\sum_{j_1=0}^{\infty}p_1^{-j_1s}\right)
\cdots
\left(\sum_{j_N=0}^{\infty}p_N^{-j_Ns}\right) \\
&=\sum_{\left(j_1,\ldots,j_N\right)\in\N^{N}}
\left(p_1^{j_1}\cdots p_N^{j_N}\right)^{-s}
\end{aligned}
$$

모든 자연수는 각자의 소인수분해에 일의적으로 대응한다는 사실을 통해, 위 식에서

$$
\prod_{n=1}^{N}\left(1-p_n^{-s}\right)^{-1} = \sum_{n=1}^{\infty}n^{-s}
$$

를 유도할 수 있다. 이 식의 좌변을 흔히 zeta 함수 $\zeta(s)$의 오일러 곱 표기라고 부른다.
또한, $n\in\N\setminus{0}$에 대하여 $n^{-s}\geq\int_{n}^{n+1}x^{-s}\,dx$가 성립하므로,

$$
\zeta(s) = \sum_{n=1}^{\infty}n^{-s}\geq \int_{1}^{\infty}x^{-s}\, dx
= \left[\frac{x^{1-s}}{1-s}\right]^{\infty}_{1} = -\frac{1}{1-s}
$$

임을 알 수 있다. 즉, $s\to1+0$일 때, $\zeta(s)\to\infty$이다.
만약 소수가 유한개인 $N$개 존재한다면,
$\lim_{s\to1+0}\prod_{n=1}^{N}\left(1-p_n^{-s}\right)^{-1}$은
발산하지 않을 것이다.
하지만 $\lim_{s\to1+0}\zeta(s)=\lim_{s\to1+0}\sum_{n=1}^{\infty}n^{-s}$가
발산함은 이미 보여졌으므로, 이는 모순이다. 따라서 소수는 무한개 존재한다. □

참고로, Euler 곱 표기를 통하여 $\sum_{n=1}^{\infty}\frac{1}{p_n}$은
발산한다는 것을 보일 수 있다.

**명제**. $\sum_{n=1}^{\infty}\frac{1}{p_n}$은 발산한다.

*증명*. $s>1$에 대해,

$$
\log\prod_{n=1}^N\left(1-p_n^{-s}\right)^{-1}
= -\sum_{n=1}^{\infty}\log\left(1-p_n^{-s}\right)
$$

이고, $p_n^{-s}\leq2^{-s}<2^{-1}$, $0\leq x\leq2^{-1}$에 대해
$-\log(1-x)\leq2x$가 성립하므로,

$$
\log\prod_{n=1}^N\left(1-p_n^{-s}\right)^{-1}
\leq2\sum_{n=1}^{N}p_n^{-s}
\leq2\sum_{n=1}^{\infty}p_n^{-s}
$$

이 때, $\sum_{n=1}^{\infty}p_n^{-s}$은 $\sum_{n=1}^{\infty}n^{-s}$의 부분열이므로
수렴한다. $N\to\infty$일 때,

$$
\log\zeta(s)\leq2\sum_{n=1}^{\infty}p_n^{-s}
$$

이므로, $s\to1+0$일 때 좌항이 발산함에 따라 우항도 발산한다. □

실제로 $s_n=\sum^{N}_{n=1}{p_n}^{-1}$은 매우 느리게 발산하는 급수이다.
$p$를 소수로 하여 $S(x)=\sum_{p\leq x}p^{-1}$로 두면,
$S(x)\sim\log(\log x)$임이 알려져 있다.

위의 소수의 무한성에 관한 정리에 따르면,
소수는 무한히 존재하므로, 적당한 $n\in\N$을 잡으면, $p\geq n$인 소수 $p$가
항상 존재할 것이다. 그러나 그 소수가 생각한 만큼 가까이에 있으리라는 보장은 없다.

**정리**(소수 사막의 존재). $\forall N\in\N$에 대해, 수열
$\{n\}_{n\in\N}=\{0,1,2,3,\ldots\}$ 중 합성수가 연속하여
$N$번 등장하는 부분(소수 사막)이 존재한다.

*증명*. $2\leq m\leq N+1$인 $m\in\N$에 대해, $m \mid (N+1)!+m$이므로,
$\{n\}_{n\in\N}$의 연속부분열인 $(N+1)!+2, (N+1)!+3, \ldots, (N+1)!+(N+1)$은
길이 $N$의 소수 사막이 된다. □

## 소수 정리

소수를 나열하여 보면, 특별한 규칙을 갖지 않는 듯이 보인다. 소수의 분포에서 규칙성을 찾아 일반화하는 것은,
수학자들의 오랜 과제였다. 여러 수학자들의 노력에 의해, 다음의 정리가 성립하는 것이 밝혀졌다.

**정리**(소수 정리). $x$ 이하의 소수의 개수를 $\pi(x)$라고 할 때,
$\pi(x)\sim\frac{x}{\log(x)}$이다. (단, $\log$는 자연로그이다.)

위 정리는 Gauss에 의해 예상되었으며, Hadamard와 de la Vallée Poussin에 의해 증명되었다.
현대에는 조금 더 오차 값이 적은 $\pi(x)$의 근사함수로
$\text{li}(x)=\int_{0}^{x}\frac{dt}{\log t}$를 많이 사용한다.
$\text{li}(x)\sim\frac{x}{\log x}$ 이므로,
$\pi(x)\sim\text{li}(x)$임을 쉽게 알 수 있다.

## 미해결 문제

소수와 관련하여, 아직 해결되지 않은 여러가지 난문을 나열한다.

**추측**(쌍둥이 소수 추측). 쌍둥이 소수는 무한히 존해한다.

쌍둥이 소수란, $p$와 $p+2$가 동시에 소수인 소수쌍 $(p,p+2)$를 의미한다.
$(3,5)$, $(5,7)$, $(11,13)$등은 쌍둥이 소수이다. 위 추측은 어느 결과로도 증명되지 않았다.

**추측**(Goldbach 예상). 모든 3보다 큰 짝수는 두 소수의 합으로 나타내는 것이 가능하다.

예를 들면, $14$는 $11+3$ 혹은 $7+7$로 나타낼 수 있다.
$20$은 $3+17$혹은 $7+13$으로 나타낼 수 있다. Brute-force 검색의 결과로 4부터 400경까지
성립하는 것이 알려졌으나 수학적인 증명은 아직 나타나지 않았다.

## 소수를 판별하는 알고리즘

### $\lfloor\sqrt{n}\rfloor$까지 나누어 보기

간단하다. 어떤 수 $n$이 소수가 아니라면, $1$이나 $n$이 아닌 $a,b$가 존재하여 $n=ab$가 성립할 것이고,
$a$와 $b$중 작은 것은 $\lfloor\sqrt{n}\rfloor$이하일 것이다. (당연히 $a$와 $b$ 모두 이를 초과하면 $n<ab$일 테니.)
즉, $2$부터 $\lfloor\sqrt{n}\rfloor$까지 하나하나 나머지를 구하여 보고, 그 중에서 나머지가 $0$인 것이 존재한다면
합성수, 존재하지 않는다면 소수일 것이다.

```python
def is_prime(number):
    if number < 2:
        return False
    i = 2
    prime = True
    while i * i <= number:
        if number % i == 0:
            prime = False
            break
        i += 1
    return prime
```

### Eratosthenes의 체로 소수 리스트 작성하기

위의 방법은 실제로 활용 가능할 정도로 느리지 않은 알고리즘이라고 할 수 있으나, (32비트 부호 정수 내의 소수를
판별하는데에 큰 지연이 없다는 정도) 잘 생각해보면 계산에 있어서 낭비가 존재한다.
예를 들어, 어떤 수가 소수인지 판별할 때, 그 수가 2로 나누어 떨어지지 않는다면, 4로 나누어 떨어지는 지
확인하는 계산을 실행하는 것은 자원 낭비이다. 왜냐하면 2의 배수가 아니면서 4의 배수인 정수는 존재하지 않기 때문이다.
또한, 단순히 하나의 수를 비교하는 경우보다도, 복수의 수가 주어진 경우라면 정해진 범위 내의 소수를 미리 구하여
나누어 보는 것이 보다 효율적이라는 사실을 증명 없이도 가늠할 수 있을 것이다.

이에 따라, 주어진 수의 최대값의 제곱근보다 작은 소수의 리스트를 만들어, 나누어 떨어지도록 하는 소수가 리스트 안에 있는지
확인하는 것으로 소수임을 판별할 수 있다.
이러한 소수의 리스트를 작성하는 알고리즘이 바로 Eratosthenes의 체이다.
원리는 간단하다. 구하고자 하는 범위를 지정하여 $2$부터 연속하는 자연수의 리스트를 작성한다.
$2$부터 시작하면, 먼저 리스트 내의 $2$의 배수를 삭제한다. 그러면 $3$이 $2$의 바로 다음 소수라는 것을 알 수 있고,
리스트 내에서 $3$의 배수를 삭제한다. 그다음 $5$, 그다음은 $7$, 그 다음은 $11$과 같이 소수의 목록을 얻을 수 있을 것이다.
이와 같은 작업은 리스트의 길이의 제곱근까지만 수행하는 것으로도 충분하다.

```python
def get_eratos(list_max):
    o_list = list(range(2,list_max+1))
    p_list = []
    while o_list[0]*o_list[0] <= list_max :
        p_list.append(o_list[0])
        o_list = list(filter(lambda x : x % o_list[0] != 0, o_list))
    p_list += o_list
    return p_list
```

<!---### Miller-Rabin 소수 판별법--->

### 정규표현식?

조금 재미있는 방식이다. 무려 한줄짜리 정규식으로 소수를 판별할 수 있다.
숏코딩이라면 숏코딩이다.

```python
import re
is_prime = lambda n : False if re.match(r'^1?$|^(11+?)\1+$', '1'*n) else True
```

원리 자체는 복잡하지 않다. 이 정규표현식의 로직을 [설명하면](https://regex101.com/?regex=^1?$|^(11%2B?)\1%2B$) 다음과 같다.

![정규표현식 설명](../images/00001.png)

우선 숫자를 일진법(단항표기법)으로 변환한다. 어려울 것 없이 그 숫자만큼 `1`을 쓰는 것이다.
여기서부터 `1`의 개수에 맞추어 `1`이 합성수개만큼 있다면 매칭되도록 할 것이다.
변환한 결과가 `1`이라면 원래의 숫자가 1이므로 매칭된다. 2개 이상의 `1`이 존재한다면
`11+?`을 통해 차례대로 `11`, `111`, `1111`, ...이 매칭되도록 할 것이다. 매칭되었다면,
매칭된 결과는 그룹에 묶여 있으므로 `\1`을 통해 다시 호출될 것이고, 나머지 부분의 `1`의 개수가
매칭된 부분의 `1`의 개수의 배수라면, `\1+`에 의해 다시 매칭되어 합성수임을 알려줄 것이다.
만약 전체 부분에서 이러한 매칭이 계속 일어나지 않는다면, 자연히 절반이 되는 부분에서 `\1`이 매치되지 않으며
탐색이 종료되고, 소수임을 알려줄 것이다.

## 특수한 소수

- $2$: 가장 작은 양의 소수이다.
- ~~$57$: [Grothendieck 소수](https://en.wikipedia.org/wiki/57_(number)#In_mathematics).~~
- $2\,147\,483\,647$: 32-bit signed int의 최고치이다. 동시에 이중 Mersenne 소수이다.

## 참고문헌

- John Derbyshire, *Prime Obsession: Bernhard Riemann and the Greatest Unsolved Problem in Mathematics*, Joseph Henry Press, 2003
- *[Goldbach Conjecture](https://mathworld.wolfram.com/GoldbachConjecture.html)*, Wolfram MathWorld
