<!DOCTYPE html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="../style.css">
<link rel="apple-touch-icon-precomposed" sizes="57x57" href="../icons/favicon-apple-touch-114.png">
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="../icons/favicon-apple-touch-114.png">
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="../icons/favicon-apple-touch-144.png">
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../icons/favicon-apple-touch-144.png">
<link rel="icon" type="image/vnd.microsoft.icon" sizes="32x32 48x48" href="../icons/favicon.ico">
<link rel="icon" sizes="128x128" href="../icons/favicon.icns">
<link rel="icon" href="../icons/favicon.png" type="image/x-icon">
<title>[Example NOTE] Fibonacci 수 구하기</title>
<style>
	.markdown-body {
		box-sizing: border-box;
		min-width: 200px;
		max-width: 980px;
		margin: 0 auto;
		padding: 45px;
	}

	.hidden {
		
	}

	@media (max-width: 767px) {
		.markdown-body {
			padding: 15px;
		}
	}
</style>
</head>
<body>
<article class="markdown-body">
<div class="hidden">
<h1>[Example NOTE] Fibonacci 수 구하기</h1>
</div>
<!---
title: '[Example NOTE] Fibonacci 수 구하기'
language: Korean
ctime: 1587251709
category: Algorithms
--->

<h2 id="fibonacci-수-수열의-정의">Fibonacci 수, 수열의 정의</h2>
<p>Fibonacci 수열은 이전의 두 수의 합이 다음 수를 결정하는 수열으로, 이 수열 $F_n$을 초항과 점화식을 이용하여 나타내면, $F_0 = 0$, $F_1 = 1$에 $F_{n+2} - F_{n+1} - F_{n}=0$로 나타내어진다.</p>
<h2 id="선형점화식의-행렬화">선형점화식의 행렬화</h2>
<p>모든 선형점화식은 행렬의 형태로 나타내어, 행렬의 거듭제곱을 통해 일반항을 구할 수 있다. Fibonacci 수의 점화식 역시 선형점화식이므로 이 방법을 이용할 수 있다.</p>
<p>이를 위해서, 다음과 같은 선형변환을 생각하자.</p>
<p>$T_A:\R^2\to\R^2$, $\begin{bmatrix}F_{n+1}\F_{n}\end{bmatrix}\mapsto\begin{bmatrix}F_{n+2}\F_{n+1}\end{bmatrix}$</p>
<p>이 선형변환에 대응하는 2차 행렬 $A$가 위에서 정의된 점화식에 의해, $A=\begin{bmatrix}1 &amp; 1 \ 1 &amp; 0\end{bmatrix}$임을 알 수 있다.</p>
<p>$\begin{bmatrix}F_{n}\F_{n-1}\end{bmatrix}=T_A\left(\begin{bmatrix}F_{n-1}\F_{n-2}\end{bmatrix}\right)=\cdots={T_A}^{n-1}\left(\begin{bmatrix}F_{1}\F_{0}\end{bmatrix}\right)$</p>
<p>이고, 행렬의 거듭제곱 형태로 변환하면,</p>
<p>$\begin{bmatrix}F_{n}\F_{n-1}\end{bmatrix}={A}^{n-1}\begin{bmatrix}1\0\end{bmatrix}$</p>
<p>으로 나타내어진다. 실제로 이 행렬의 거듭제곱 꼴을 행렬의 대각화로 일반화하여, Fibonacci 수열의 일반항을 유도할 수 있다. 실제로 구하여지는 일반항은 다음과 같다.</p>
<p>$\frac1{\sqrt5}\left(\left(\frac{1+\sqrt5}2\right)^n-\left(\frac{1-\sqrt5}2\right)^n\right)$</p>
<h2 id="binary-search를-통한-계산">Binary search를 통한 계산</h2>
<p>위의 일반항을 계산하는 것은 신뢰성이 높은 컴퓨터 알고리즘으로 보기 어렵다. 실수의 곱셈에는 정밀도의 한계가 있으므로 적당히 큰 수에 대해서는 적용되기 어려움이 있고, 유리수의 확장환 계산을 통하여 계산하는 것도 가능하지만 사실 이는 행렬의 곱셈을 다시 구현하는 것과 상등하다. 조금 더 적용하기에 적합한 방식으로는, 행렬을 통해 거듭제곱이 가능한 대수 구조를 만들어 내었으므로, binary search를 통해 행렬의 거듭제곱을 구하는 것이 있다. 아래는 이 계산을 Python으로 구현한 것이다.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">def</span> mat_m(m_1,m_2):</span>
<span id="cb1-2"><a href="#cb1-2"></a>    res_m <span class="op">=</span> [m_1[<span class="dv">0</span>]<span class="op">*</span>m_2[<span class="dv">0</span>]<span class="op">+</span>m_1[<span class="dv">1</span>]<span class="op">*</span>m_2[<span class="dv">2</span>],</span>
<span id="cb1-3"><a href="#cb1-3"></a>             m_1[<span class="dv">0</span>]<span class="op">*</span>m_2[<span class="dv">1</span>]<span class="op">+</span>m_1[<span class="dv">1</span>]<span class="op">*</span>m_2[<span class="dv">3</span>],</span>
<span id="cb1-4"><a href="#cb1-4"></a>             m_1[<span class="dv">2</span>]<span class="op">*</span>m_2[<span class="dv">0</span>]<span class="op">+</span>m_1[<span class="dv">3</span>]<span class="op">*</span>m_2[<span class="dv">2</span>],</span>
<span id="cb1-5"><a href="#cb1-5"></a>             m_1[<span class="dv">2</span>]<span class="op">*</span>m_2[<span class="dv">1</span>]<span class="op">+</span>m_1[<span class="dv">3</span>]<span class="op">*</span>m_2[<span class="dv">3</span>]]</span>
<span id="cb1-6"><a href="#cb1-6"></a>    <span class="cf">return</span> res_m <span class="co"># matrix multiplication</span></span>
<span id="cb1-7"><a href="#cb1-7"></a></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="kw">def</span> mat_pow(m,n):</span>
<span id="cb1-9"><a href="#cb1-9"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb1-10"><a href="#cb1-10"></a>        <span class="cf">return</span> m</span>
<span id="cb1-11"><a href="#cb1-11"></a>    k <span class="op">=</span> n <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>    <span class="cf">return</span> mat_m(mat_pow(m,k),mat_pow(m,n<span class="op">-</span>k)) <span class="co"># binary powering matrix</span></span>
<span id="cb1-13"><a href="#cb1-13"></a></span>
<span id="cb1-14"><a href="#cb1-14"></a><span class="kw">def</span> fib(n):</span>
<span id="cb1-15"><a href="#cb1-15"></a>    mat_f <span class="op">=</span> [<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>]            <span class="co"># matrix form of linear recurrence relation</span></span>
<span id="cb1-16"><a href="#cb1-16"></a>    <span class="cf">return</span> mat_pow(mat_f,n)[<span class="dv">0</span>]   <span class="co"># nth fibonacci number by O(log(n))</span></span></code></pre></div>
<div class="hidden">
<hr>
<p>Category: <a href="../category/Algorithms.html">Algorithms</a> | Language: <a href="../language/Korean.html">Korean</a> | <a href="https://github.com/loudcolour/loudcolour.github.io/blame/master/blog/fibonacci.html">Blame</a> | <a href="https://github.com/loudcolour/loudcolour.github.io/commits/master/blog/fibonacci.html">History</a></p>
<p>Created: <code>1587251709</code>, Modified: <code>1587285105</code></p>
</div>
<hr>
</article>
</body>
